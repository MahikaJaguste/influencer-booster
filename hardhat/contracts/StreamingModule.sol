// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;
import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol";

import {ISuperfluid} from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol";
import {ISuperToken} from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol";
import {SuperTokenV1Library} from "@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol";

interface GnosisSafe {
    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.
    /// @param to Destination address of module transaction.
    /// @param value Ether value of module transaction.
    /// @param data Data payload of module transaction.
    /// @param operation Operation type of module transaction.
    function execTransactionFromModule(
        address to,
        uint256 value,
        bytes calldata data,
        Enum.Operation operation
    ) external returns (bool success);
}

contract StreamingModule is SignatureDecoder {
    string public constant NAME = "Streaming Module";
    string public constant VERSION = "0.1.0";

    using SuperTokenV1Library for ISuperToken;

    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH =
        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;
    // keccak256(
    //     "EIP712Domain(uint256 chainId,address verifyingContract)"
    // );

    bytes32 public constant SUPER_ALLOWANCE_TYPEHASH =
        0xd5157347abe2571626499c3f94dc2081fa1952d72911c24f3eaf5e9e0802c922;
    // keccak256(
    //     "SuperAllowance(address safe,address influencer,bytes32 tweetId,uint96 basePaymentFlowRate,uint8 paymentPlan,uint16 nonce)"
    // );

    // mapping Safe => Influencer => bool (is whitelisted Influencer)
    mapping(address => mapping(address => bool)) public influencers;
    // mapping Safe => Influencer => Tweet ID
    mapping(address => mapping(address => bytes32)) public tweetIds;
    // mapping Safe => Influencer => Base Payment Flow Rate
    mapping(address => mapping(address => uint96)) public basePaymentFlowRate;
    // mapping Safe => Influencer => Payment Plan
    mapping(address => mapping(address => uint8)) public paymentPlan;
    // mapping Safe => Influencer => Nonce
    mapping(address => mapping(address => uint8)) public nonces;

    address private boosterAdmin;
    ISuperToken private superToken;

    constructor(address _boosterAdmin, address _superToken) {
        boosterAdmin = _boosterAdmin;
        superToken = ISuperToken(_superToken);
    }

    modifier isBoosterAdmin() {
        require(msg.sender == boosterAdmin, "Not authorized");
        _;
    }

    function updateBoosterAdmin(address _boosterAdmin) public isBoosterAdmin {
        boosterAdmin = _boosterAdmin;
    }

    /// @dev This function needs to be called by the safe to approve a deal for itself.
    /// @param _influencer Influencer address.
    /// @param _basePaymentFlowRate Base payment flow rate.
    /// @param _paymentPlan Payment plan.
    function approveDeal(
        address _influencer,
        uint96 _basePaymentFlowRate,
        uint8 _paymentPlan
    ) public {
        influencers[msg.sender][_influencer] = true;
        basePaymentFlowRate[msg.sender][_influencer] = _basePaymentFlowRate;
        paymentPlan[msg.sender][_influencer] = _paymentPlan;
    }

    /// @dev This function needs to be called by the platform admin after checking that the tweet is relevant to this deal.
    /// @param _safe Safe contract address.
    /// @param _influencer Influencer address.
    /// @param _tweetId Tweet ID.
    function initDeal(
        address _safe,
        address _influencer,
        bytes32 _tweetId
    ) public isBoosterAdmin {
        tweetIds[_safe][_influencer] = _tweetId;
    }

    /// @dev Getter function for details of a deal.
    /// @param _safe Safe contract address.
    /// @param _influencer Influencer address.
    function getDealInfo(
        address _safe,
        address _influencer
    ) public view returns (bool, bytes32, uint96, uint8, uint8) {
        return (
            influencers[_safe][_influencer],
            tweetIds[_safe][_influencer],
            basePaymentFlowRate[_safe][_influencer],
            paymentPlan[_safe][_influencer],
            nonces[_safe][_influencer]
        );
    }

    /// @dev This function needs to be called by the influencer to start the deal.
    /// (The booster admin is also eligible to call this function)
    ///
    /// @param _safe Safe contract address.
    /// @param _influencer Influencer address.
    /// @param signature Signature generated by the influencer to start the deal.
    function executeAllowanceTransfer(
        GnosisSafe _safe,
        address _influencer,
        bytes memory signature
    ) public {
        (
            bool isInfluencer,
            bytes32 _tweetId,
            uint96 _basePaymentFlowRate,
            uint8 _paymentPlan,
            uint8 _nonce
        ) = getDealInfo(address(_safe), _influencer);

        require(isInfluencer, "Not an influencer");
        require(
            _tweetId != 0,
            "Tweet ID not set. Please start the deal first."
        );
        require(
            _basePaymentFlowRate != 0,
            "Base Payment Flow Rate not set. Please start the deal first."
        );
        require(
            _paymentPlan != 0,
            "Payment Plan not set. Please start the deal first."
        );
        require(_nonce == 0, "Deal already executed.");

        nonces[address(_safe)][_influencer] = _nonce + 1;

        bytes memory dealHashData = generateDealHashData(
            address(_safe),
            _influencer,
            _tweetId,
            _basePaymentFlowRate,
            _paymentPlan,
            _nonce
        );

        checkSignature(_influencer, signature, dealHashData);
    }

    /// @dev Returns the chain id used by this contract.
    function getChainId() public view returns (uint256) {
        uint256 id;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            id := chainid()
        }
        return id;
    }

    /// @dev Generates the data for the deal hash (required for signing)
    function generateDealHashData(
        address _safe,
        address _influencer,
        bytes32 _tweetId,
        uint96 _basePaymentFlowRate,
        uint8 _paymentPlan,
        uint16 _nonce
    ) private view returns (bytes memory) {
        uint256 chainId = getChainId();
        bytes32 domainSeparator = keccak256(
            abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this)
        );
        bytes32 dealHash = keccak256(
            abi.encode(
                SUPER_ALLOWANCE_TYPEHASH,
                _safe,
                _influencer,
                _tweetId,
                _basePaymentFlowRate,
                _paymentPlan,
                _nonce
            )
        );
        return
            abi.encodePacked(
                bytes1(0x19),
                bytes1(0x01),
                domainSeparator,
                dealHash
            );
    }

    /// @dev Generates the deal hash that should be signed to start a deal.
    function generateDealHash(
        address _safe,
        address _influencer,
        bytes32 _tweetId,
        uint96 _basePaymentFlowRate,
        uint8 _paymentPlan,
        uint16 _nonce
    ) public view returns (bytes32) {
        return
            keccak256(
                generateDealHashData(
                    _safe,
                    _influencer,
                    _tweetId,
                    _basePaymentFlowRate,
                    _paymentPlan,
                    _nonce
                )
            );
    }

    function checkSignature(
        address _influencer,
        bytes memory signature,
        bytes memory dealHashData
    ) private view {
        address signer = recoverSignature(signature, dealHashData);
        require(
            _influencer == signer || boosterAdmin == signer,
            "Invalid signature"
        );
    }

    // We use the same format as used for the Safe contract, except that we only support exactly 1 signature and no contract signatures.
    function recoverSignature(
        bytes memory signature,
        bytes memory dealHashData
    ) private view returns (address owner) {
        // If there is no signature data msg.sender should be used
        if (signature.length == 0) return msg.sender;
        // Check that the provided signature data is as long as 1 encoded ecsda signature
        require(signature.length == 65, "signatures.length == 65");
        uint8 v;
        bytes32 r;
        bytes32 s;
        (v, r, s) = signatureSplit(signature, 0);
        // If v is 0 then it is a contract signature
        if (v == 0) {
            revert("Contract signatures are not supported by this module");
        } else if (v == 1) {
            // If v is 1 we also use msg.sender, this is so that we are compatible to the GnosisSafe signature scheme
            owner = msg.sender;
        } else if (v > 30) {
            // To support eth_sign and similar we adjust v and hash the dealHashData with the Ethereum message prefix before applying ecrecover
            owner = ecrecover(
                keccak256(
                    abi.encodePacked(
                        "\x19Ethereum Signed Message:\n32",
                        keccak256(dealHashData)
                    )
                ),
                v - 4,
                r,
                s
            );
        } else {
            // Use ecrecover with the messageHash for EOA signatures
            owner = ecrecover(keccak256(dealHashData), v, r, s);
        }
        // 0 for the recovered owner indicates that an error happened.
        require(owner != address(0), "owner != address(0)");
    }

    function transfer(
        GnosisSafe safe,
        address token,
        address payable to,
        uint96 amount
    ) private {
        bytes memory data = abi.encodeWithSignature(
            "transfer(address,uint256)",
            to,
            amount
        );
        require(
            safe.execTransactionFromModule(token, 0, data, Enum.Operation.Call),
            "Could not execute token transfer"
        );
    }
}
